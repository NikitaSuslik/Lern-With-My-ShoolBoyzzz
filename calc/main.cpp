#include <iostream>
#include <string>

using namespace std;

string convert_to_string(int);                  //Функция переводящая число из цифрового варианта в текстовый
int operant(char);                              //функция распознающая символ операции
enum oper {sum, raz, umn};                      //перечисление операций
//                         0          1              2             3                4               5              6              7               8                9
static string nums[] = {"",        "Один ",       "Два ",        "Три ",        "Четыре ",       "Пять ",       "Шесть ",       "Семь ",       "Восемь ",       "Девать ",
                 /*+10*/"Десять ", "Одинадцать ", "Двенадцать ", "Тринадцать ", "Четырнадцать ", "Пятнадцать ", "Шестнадцать ", "Семнадцать ", "Восемнадцать ", "Деватнадцать ",
                 /*+20*/"",        "",            "Двадцать ",   "Тридцать ",   "Сорок ",        "Пятьдесят ",  "Шестьдесят ",  "Семьдесят ",  "Восемьдесят ",  "Девяносто ",
                 /*+30*/"",        "Сто ",        "Двести ",     "Триста ",     "Четыреста ",    "Пятьсот ",    "Шестьсот ",    "Семьсот ",    "Восемьсот ",    "Девятьсот ",
                 /*+40*/"",        "Одна ",       "Две ",        "",            "",              "",            "",             "",            "",              "",
                 /*+50*/"Тысяча ", "Тысячи ",     "Тысяч ",      "Миллион ",    "Миллиона ",     "Миллионов ",  "Миллиард ",    "Миллиарда ",  "Миллиардов ",   ""};
// составляем массив так что бы при последующей конвертации цифра соответсвовала тексту и при конвертации простых чисел, десятых и сотых долей мы будем производить только сдвиг адреса


int main()
{
    while(1){                                   //бесконечный цикл что бы программа считала и конвертировала столько, сколько я захочу
        char com;                               //переменная для входящего символа
        int var[2] = {0, 0};                    //операнды
        char op;                                //знак операции
        bool first_simbol = true, negative = false;// костыль на определение отрицательного числа
        bool start = true;                      //флаг на старт расчета
        while(1){                               //еще один бесконечный цикл потому что я их люблю
            com = getchar();                    //посимвольное чтение из потока позволяет использовать нам 'q' в любом месте что бы выйти из программы
            if(com == 'q') exit(0);             //выход из программы
            if(com == '/'){                     //защита от деления
                cout << "Я пока не умею делить  :(\n";
                start = false;
                break;
            }
            if(first_simbol){                   //если читаем первый символ нужно проверить
                if(com == '-') negative = true;
                else{
                    var[0] *= 10;               //смещение разряда
                    var[0] += atoi(&com);       //добавление введенной цифры в виде младшего разряда
                }
                first_simbol = false;
            }
            else if(com == '+' || com == '-' || com == '*'){//если входящий символ один из знаков операции
                op = com;                       //запись знака операции
                break;
            }
            else{
                var[0] *= 10;                   //аналогично
                var[0] += atoi(&com);
            }
        }
        if(negative) var[0] *= -1;
        first_simbol = true;
        negative = false;
        while(1){                               //еще один бесконечный цикл потому что я их люблю, хотя можно было бы и  while(com != '\n')
            com = getchar();                    //посимвольное чтение из потока позволяет использовать нам 'q' в любом месте что бы выйти из программы
            if(com == 'q') exit(0);             //выход из программы
            if(com == '\n') break;              //завершение считывания символов
            if(first_simbol){                   //если читаем первый символ нужно проверить
                if(com == '-') negative = true;
                else{
                    var[1] *= 10;               //смещение разряда
                    var[1] += atoi(&com);       //добавление введенной цифры в виде младшего разряда
                }
                first_simbol = false;
            }
            else if(com == '+' || com == '-' || com == '*'){//если входящий символ один из знаков операции
                op = com;                       //запись знака операции
            }
            else{
                var[1] *= 10;                   //аналогично
                var[1] += atoi(&com);
            }
        }
        if(negative) var[1] *= -1;
        if (start){
            int res = 0;                        //переменная хранящая рузультат
            switch (operant(op)) {              //в switch передаем результат функции распознавания операции
            case oper::sum:                     //сумма
                res = var[0] + var[1];
                break;
            case oper::raz:                     //разность
                res = var[0] - var[1];
                break;
            case oper::umn:                     //умножение
                res = var[0] * var[1];
                break;
            }
            cout << endl << convert_to_string(res) << endl; //выводим отконвертированный результат
        }
    }
    return 0;
}


string convert_to_string(int res){
    int cur = res, del = 1000000000, tmp = cur / del; //текущее число что бы обрезать старшие разряды, Делитель, временное число
    string out;                                 //Строка с конечным числом в виде текста
    if(cur < 0){
        cur *= -1;
        out.append("Минус ");            //Проверка на отрицательность
    }
    if(cur == 0){                               //если число равно нулю то просто пишем ноль и выходим из функции
        out = "Ноль";
        return out;
    }
    int razr = 0;                               //по сути делитель но в более удобном виде для дальнейшей операции по опеределению миллиардов, миллионов и тысяч
    while(del >= 1){                            //пока делитель не станет меньше еденицы
        if(tmp >= 1){                           //если временное число больше или равно еденице, значит с помощь данного делителя мы получили сотую, десятую или еденичную часть для конвертации
                                                //в дальнейшем с помощью того же делителя мы определим какая это часть в начальном числе: Миллиардная, миллионная, тысячная или еденичная
            int tmp_s[3];                       //[сотый][десятичный][еденичный] массив для хранения сотой части поразрядно

            int i = 10;                         //Делитель для выявления разрядов
            tmp_s[2] = (tmp%i)/(i/10);          //еденичный разряд пример: tmp = 345 (345%10)/(10/10) =5/1 = 5
            i *= 10;                            //переход к следующему разряду
            tmp_s[1] = (tmp%i)/(i/10);          //десятый разряд пример (345%100)/(100/10) = 45/10 = 4
            i *= 10;
            tmp_s[0] = (tmp%i)/(i/10);          //сотый разряд пример (345%1000)/(1000/10) = 345/100 = 3

            //сама конвертация

            out.append(nums[tmp_s[0]+30]);      //сотая часть в виде текста никак не изменятеся так что пишем как есть обращась в массив по адресу равному самому числу и смещенному на 30
            if(tmp_s[1] == 1){                  //если десятая часть равна еденице в случае "десять", "пятнадцать", "семнадцать" и т.д.
                out.append(nums[tmp_s[2]+10]);  //адрес в массиве равен самому числу смещенному на 10. пример "шестнадцать" = nums[6+10]
            }
            else{
                out.append(nums[tmp_s[1]+20]);  //если десятая чать не равна 1 то просто пишем ту десятую часть которой
                if(del == 1000 && (tmp_s[2] == 1 || tmp_s[2] == 2)){//если делитель тысяча то проверяем еденичную часть на 1 или 2 что выводилось "одна тысяча" или "две тысячи"
                                                                    //а не "один тысяча" или "два тысячи"
                    out.append(nums[tmp_s[2]+40]);//адреса слов "одна" и "две" сама цифра 1 или 2 + 40
                }
                else out.append(nums[tmp_s[2]]);//иначе просто "три", "четыре" и т.д.
            }
            if(razr <= 6 && ((tmp_s[0]+tmp_s[1]+tmp_s[2]) != 0)){//когда razr > 6 - значит мы перешили к еденичной части числа, а значит чсило записывается как есть баз названий
                                                                 //так же проверяем, что бы в разрядах не стояли 0, что бы не было такого:
                                                                 // 1000345 = "один миллион тысяч триста сорок пять"
                if (tmp_s[1] == 1) {            //если в десятичной части стоит 1 - "пятнадцать", "семнадцать" то миллион и миллиард должны оканчиваться на "ов" - " пятнадцать миллионов"
                                                // "тысяча" - "тысяч"
                    out.append(nums[58-razr]);  //при уменьшении делителя мы увеличиваем razr что бы адрес слова смещался от нужного склонения миллиарда(как старшего разряда) до тысячи
                }                               //nums[58-0] = "мыллиардов" nums[58-3] = "миллионов" nums[58-6] = "тысяч"
                else if (tmp_s[2] == 1){        //если младший разряд равен одному
                    out.append(nums[56-razr]);
                }
                else if (tmp_s[2] == 2 || tmp_s[2] == 3 || tmp_s[2] == 4){
                    out.append(nums[57-razr]);
                }
                else out.append(nums[58-razr]);
            }
        }
        cur -= tmp * del;                       //вычитание старшой части из начального числа
        del /= 1000;                            //уменьшение делителя на 1000
        razr += 3;
        if(del != 0) tmp = cur / del;           //так как integer округляется до целой части, проверка на 0 исключает cur/0
    }
    return out;
}


int operant(char op){
    switch (op) {
    case '+':
        return oper::sum;
    case '-':
        return oper::raz;
    case '*':
        return oper::umn;
    }
}
